"prompt":"How can you initialise the state of a service without replaying all significant input messages?",
"answer":"Design the service to include all relevant state in output messages, and configure replay options accordingly. Read messages from the output queue in reverse order and invoke a specific method in the service to use these messages to recreate state. The service can stop this process once it is satisfied that all state has been recreated." 

"prompt":"What configuration is needed for replaying output messages to initialise state?",
"answer":"The configuration for state replay using output queue includes setting the value OUTPUT_REVERSE to indicate that this service will read events in most-recent-first order from its output queue and replay them until satisfied that its state has been completely reconstructed. Setting the startFromStrategy to LAST_WRITTEN is an instruction that once initialised, the service should begin processing input events that arrived after the last event that on the output queue (which would be the first event that it reapplied to rebuild state). In some cases, this value can be set to END to begin looking at events that arrive only after initialisation is complete." 

"prompt":"What changes need to be made to the service implementation for (re)building state from output messages?",
"answer":"The implementation class must be able to handle output events as well as input events. It must also contain logic to determine whether the state has been completely reconstituted, as the output messages may not contain all state. This can be done by extending the 'normal' service implementation class and introducing the additional functionality. The PositionsListener specifies that the service can handle positions() events, OutputReverseListener specifies that the class has the stateReplayed() method to determine whether replay of output messages should stop. Populate the main positions structure with the information that was published in the event that is being replayed here. In this case, the output events we are replaying contain all the state, so only one is required." 

"prompt":"What is the purpose of the recipes in the Diagnostics and Monitoring section?",
"answer":"The recipes in the Diagnostics and Monitoring section demonstrate how to discover more about how messages pass through an application. They provide ways to find out which service posted a message, trace the flow of a message through an application, display latencies in message processing, establish simple heartbeats between two services, and determine availability of services and their dependencies using heartbeats."
