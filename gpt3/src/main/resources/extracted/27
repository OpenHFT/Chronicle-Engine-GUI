9.4 Simple Heartbeat Monitoring
Problem
You want to set up a simple heartbeat capability between two services.
Solution
Use HeartbeatSource and HeartbeatListener.
Discussion
Heartbeat is a useful feature of Chronicle services, which allows a service to verify that another service is available. 
It is similar in concept to PeriodicUpdate, however its use cases are more focussed on discovering when there are 
issues in communication between services.
This recipe demonstrates the simplest use of Heartbeat, simply operating between a pair of services. The example 
used is, once more, the transaction service seen in earlier recipes. The structure of the application can be seen below:
 
and its configuration file is shown below:
Listing 108. Application Configuration
!ChronicleServicesCfg {
    queues: {
        transactionIn: { path: data/transactionIn, sourceId: 1 },
        transactionOut: { path: data/transactionOut, sourceId: 2 },
        upstreamIn: { path: data/upstreamIn, sourceId: 100 },
        downstreamOut: { path: data/downstreamOut, sourceId: 101 },
    },
    services: {
        transactionSvc: {
            inputs: [ transactionIn ],
            output: transactionOut,
            implClass: !type
software.chronicle.services.cookbook.example9c.services.Transact
ionSvcImpl,         },
        transactionUpstream: {
            inputs: [upstreamIn ],        
            output: transactionIn,
            implClass: !type
software.chronicle.services.cookbook.example9c.services.TransactionSvcUpstream,
            periodicUpdateMS: 3000,       
            periodicUpdateInitialMS: 500,
            heartbeatMS: 2000,            
            heartbeatMSInitial: 1000,
        },
        transactionDownstream: {
            inputs: [ transactionOut ],
            output: downstreamOut,
            implClass: !type
software.chronicle.services.cookbook.example9c.services.TransactionSvcDownstream,
        }
    },
}
The main changes from previous examples of this application are in the configuration of the 
transactionUpstream service.
1.	The input queue is required to supply the timer related events (periodicUpdate and heartbeat) to the service. Its 
configuration is added to the queues section
2.	Timers for the periodicUpdate events: every 3 seconds after an intial delay of 0.5 seconds (to allow 
configuration to complete)
3.	Timers for the heartbeat events: every 2 seconds after an initial delay of 1 second (to allow configuration to 
complete)
The Upstream Service
The upstream service needs be defined to accept both periodicUpdate and heartbeat events, this is done by 
implementing the necessary interfaces:
Listing 109. Upstream service class header
public class TransactionSvcUpstream     implements HeartbeatSource, 
PeriodicUpdateSource, ServiceLifecycleListener {
The required methods must be defined in the class. In the case of HeartbeatSource there are two methods:
Listing 110. Methods for setting up Heartbeat
 
 
The first of these, heartbeatDefinitions(), is required by the interface, but in this example we do not use any 
of the functionality it represents. The implementation is therefore empty apart from a diagnostic log message. We will 
see a more realistic use case for this method in the following recipe.
The second of these, heartbeatTimer is the handler for the heartbeat events that are delivered to the service. 
In this case, the handler will construct a heartbeat message containing the name of the sending service and the 
current time. This is then posted to the output queue, from where it will be read by the downstream service 
responsible for monitoring. In this example, this is the transactionSvc.

 
 
