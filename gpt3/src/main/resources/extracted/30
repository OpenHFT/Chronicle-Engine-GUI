The Chronicle Approach to Microservices
Systems built with Chronicle software are typically deployed into highly latency sensitive environments. Typical requirements are that a response to an event should be generated within 30 microseconds, with a 99% generated within 100 microseconds. Meeting these requirements requires careful attention to all aspects of coding and architecture.
However, we have found that the Microservices architectural approach described above provides a good basis for building effective solutions that can be used in such demanding environments. We use the Lambda Architecture as a model for our view of Microservices:
Lambda Architecute
Key aspects of this approach are that a function (Microservice) receives events from a source of data, reacts in some way to the events and generates output based on processing the input data. Lambda architecture is based on the idea that the data source for the function contains the complete history of all events and operates in an append-only manner. Moreover, the function is stateless - any state information it requires is derived from its input event(s). This is a simple model and can lead to efficient implementations.
However, it will not be suitable in every case. In particular for some functions it will be necessary to have state that is constructed from historical inputs, and not just from the current input. It is not practical to reconstruct this state on every input, so a slight variation of the approach can be used, where a function caches state locally.
We do not expect the semantics of the function to change as a result of storing state - it is purely an optimisation, and at any point the state can be recreated from the inputs if necessary:
Lambda Architecture with State
Transmission of events to, and from, a function in this way can be viewed as asynchronous messaging, which provides the most efficient mechanism for inter-service communication.
Notice that we do not mention any specific transport for these events. In the case where the sending and receiving services are part of the same process (i.e. running inside the same JVM) the transport can be as simple as a method invocation. However, in the more likely case where the services are in separate JVMs, some form of efficient cross-process transport is required. The interface from the services themselves to this transport should not mandate one of these over the other.
It should be clear that the above approach allows Chronicle microservices defined in this way to be chained together to produce more sophisticated processing pipelines, for example:
Chained services
The "Normalising Function", and the "Function for External Messages" are examples of the simpler form of Lambda architecture. Their job is simple - to convert to and from an application specific canonical representation of the messages being sent to and from the system.
The main function processes requests as they appear in its input, which again is an example of an immutable collection of input messages. However, the function is able to cache state constructed from these messages locally, allowing it to perform operations that are more complex than simple "one in one out" conversions. It will have access to historical data to aid in its calculations.
As this central functionality becomes yet more complex, it may involve sub-functions to enrich the data through accessing one or more databases, or other calculations such as the application of strategies that take some time to complete. To avoid blocking the main path of processing through the system, these potentially blocking operations can be factored out into separate services, each with the same underlying model:
Services with feedback
This diagram shows a basic trading system that receives Market Data from exchanges as FIX messages, transforms them into an internal format and passes them to a central controlling function. From here the events are passed to one or more Strategy functions, each of which may produce a recommendation to place an order through a further Order Management system, which itself sends the orders to the exchanges using FIX messages. At all stages, the aim is to keep the individual Function components operating as efficiently as possible in order to minimise the latency between an inbound FIX message and any resulting order being places as a result of its analysis.